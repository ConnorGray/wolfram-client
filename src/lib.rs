//! Wolfram client SDK.
//!
//! This library provides an easy to use API for launching and communicating
//! with a [`WolframKernel`], the main executable in a Wolfram installation.
//!
//! During traditional usage of Wolfram, the user client is the graphical
//! notebook interface, often called the 'FrontEnd'. The user enters commands
//! for evaluation, and the FrontEnd client sends them to the Kernel for
//! evaluation, and displays and printed output and the returned result.
//!
//! See also: ['What is the FrontEnd?'](https://mathematica.stackexchange.com/questions/84173/what-is-the-frontend)
//!
//! This library can be used to implement a programmatic client that can perform
//! evaluations and display output generated by the Wolfram Kernel.
//!
//!
//! ## Use-cases
//!
//! * Call into Wolfram code to add functionality to an existing program.
//!
//!
//! [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
#[cfg(test)]
mod tests;

use std::path::Path;

use wolfram_app_discovery::WolframApp;
use wolfram_expr::{Expr, ExprKind, Symbol};
use wstp::kernel::WolframKernelProcess;

/// Handle facilitating structured communication with a running [`WolframKernel`].
///
/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
#[derive(Debug)]
pub struct WolframSession {
	process: WolframKernelProcess,
	state: WolframSessionState,
}

#[non_exhaustive]
#[derive(Debug, thiserror::Error)]
pub enum WolframSessionError {
	#[error(
		"expression is not a known FrontEnd or Kernel packet type: {expr}"
	)]
	ExpectedPacket { expr: Expr },
	#[error(
		"malformed packet expression is malformed: {message} (expr: {expr})"
	)]
	MalformedPacket { expr: Expr, message: String },
	#[error("packet was not expected in the current state: {packet:?}")]
	UnexpectedPacket { packet: Packet },

	#[error("the WSTP link used to communicate with the kernel yielded an unexpected error: {0}")]
	WstpError(wstp::Error),
	#[error("the WSTP link used to communicate with the kernel is dead")]
	DeadLink,

	#[error("client only supports operation when the current state matches '{required_state}', but the current state was: {current:?}")]
	OperationNotSupportedInCurrentState {
		required_state: String,
		current: WolframSessionState,
	},
}

//======================================
// Session State
//======================================

#[derive(Debug, Clone)]
pub enum WolframSessionState {
	/// The Kernel process was launched but is not yet ready for user input.
	Launching,

	/// The Kernel is waiting for further input from the user.
	///
	/// Indicates that the Kernel sent an `InputNamePacket`.
	WaitingForInput,

	/// An evaluation is being performed -- the client is waiting for output from
	/// the Kernel.
	Evaluating,

	/// The WSTP link connection to the Kernel died.
	DeadLink,
}

//======================================
// Packets
//======================================

/// Packet type used in `client <=> WolframKernel` communication.
///
/// ## Request/Response packets
///
/// | Client sends...              | Kernel responds...           |
/// |------------------------------|------------------------------|
/// | [`Packet::EnterExpression`]  | [`Packet::ReturnExpression`] |
/// | [`Packet::EnterText`]        | [`Packet::ReturnText`]       |
/// | [`Packet::Evaluate`]         | [`Packet::Return`]           |
///
/// ## Evaluation non-final output
///
/// The following packet types are sent by the Kernel to the client when output
/// is printed during the evaluation:
///
/// | Kernel sends...         |
/// |-------------------------|
/// | [`Packet::Expression`]  |
/// | [`Packet::Text`]        |
/// | [`Packet::Message`]     |
#[derive(Debug)]
pub enum Packet {
	/// [`InputNamePacket`]
	///
	/// [`InputNamePacket`]: https://reference.wolfram.com/language/ref/InputNamePacket
	InputName(String),

	/// [`OutputNamePacket`]
	///
	/// [`OutputNamePacket`]: https://reference.wolfram.com/language/ref/OutputNamePacket
	OutputName(String),

	/// [`EnterExpressionPacket`]
	///
	/// [`EnterExpressionPacket`]: https://reference.wolfram.com/language/ref/EnterExpressionPacket
	EnterExpression(Expr),

	/// [`ReturnExpressionPacket`]
	///
	/// [`ReturnExpressionPacket`]: https://reference.wolfram.com/language/ref/ReturnExpressionPacket
	ReturnExpression(Expr),

	/// [`EnterTextPacket`]
	///
	/// [`EnterTextPacket`]: https://reference.wolfram.com/language/ref/EnterTextPacket
	EnterText(String),

	/// [`ReturnTextPacket`]
	///
	/// [`ReturnTextPacket`]: https://reference.wolfram.com/language/ref/ReturnTextPacket
	ReturnText(String),

	/// [`EvaluatePacket`]
	///
	/// [`EvaluatePacket`]: https://reference.wolfram.com/language/ref/EvaluatePacket
	Evaluate(Expr),

	/// [`ReturnPacket`]
	///
	/// [`ReturnPacket`]: https://reference.wolfram.com/language/ref/ReturnPacket
	Return(Expr),

	/// `ExpressionPacket`.
	///
	/// This packet type has no official documentation. Observed behavior:
	///
	/// - [`ExpressionPacket[BoxData[..]]`] is sent from the Kernel to the FE
	///   when `Print[..]` is evaluated.
	Expression(Expr),

	/// [`TextPacket`]
	///
	/// [`TextPacket`]: https://reference.wolfram.com/language/ref/TextPacket
	Text(String),

	/// [`MessagePacket`]
	///
	/// [`MessagePacket`]: https://reference.wolfram.com/language/ref/MessagePacket
	Message(Symbol, String),

	/// [`SyntaxPacket`]
	///
	/// [`SyntaxPacket`]: https://reference.wolfram.com/language/ref/SyntaxPacket
	Syntax(u64),
}

//======================================
// Impls
//======================================

#[rustfmt::skip]
macro_rules! require_state_matches {
	(let $expected:pat = $state:expr) => {
		let state: &crate::WolframSessionState = $state;

		let $expected = state else {
			let error = WolframSessionError::OperationNotSupportedInCurrentState {
				required_state: String::from(stringify!($expected)),
				current: state.clone()
			};

			panic!("{error}")
		};
	};
}

impl WolframSession {
	/// Launch the default [`WolframKernel`] found on this computer.
	///
	/// This method uses
	/// [`wolfram-app-discovery`](https://crates.io/crates/wolfram-app-discovery)
	/// to automatically locate any local Wolfram installations.
	///
	/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
	pub fn launch_default_kernel() -> Result<Self, wstp::kernel::Error> {
		let app = WolframApp::try_default()
			.expect("unable to find any Wolfram Language installations");

		let exe = app.kernel_executable_path().unwrap();

		WolframSession::launch_kernel(exe.as_path())
	}

	/// Start a new `WolframSession` by spawning a new [`WolframKernel`]
	/// process.
	///
	/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
	pub fn launch_kernel(
		kernel_exe: &Path,
	) -> Result<Self, wstp::kernel::Error> {
		let kernel_exe = kernel_exe.to_owned();

		let process = WolframKernelProcess::launch(&kernel_exe)?;

		Ok(WolframSession {
			process,
			state: WolframSessionState::Launching,
		})
	}

	pub fn packets(&mut self) -> WolframSessionPackets {
		WolframSessionPackets { kernel: self }
	}

	pub fn state(&self) -> &WolframSessionState {
		let WolframSession { process: _, state } = self;

		state
	}

	/// Enter `input` to be evaluated by the Kernel.
	///
	/// This function sends [`Packet::EnterText`] to the Kernel.
	///
	/// # Panics
	///
	/// This function panics if the underlying call to
	/// [`self.try_enter_text()`][Self::try_enter_text] returns an error.
	pub fn enter_text(&mut self, input: &str) {
		self.try_enter_text(input)
			.expect("kernel session error during enter_text()")
	}

	/// Enter `input` to be evaluated by the Kernel.
	///
	/// This function sends [`Packet::EnterText`] to the Kernel.
	///
	/// # Errors
	///
	/// This function will return an error if:
	///
	/// * [`self.state()`][Self::state] is not [`WolframSessionState::WaitingForInput`]
	/// * The underlying [`put_packet()`][Self::put_packet] call returns an error.
	pub fn try_enter_text(
		&mut self,
		input: &str,
	) -> Result<(), WolframSessionError> {
		require_state_matches!(let WolframSessionState::WaitingForInput = self.state());

		self.put_packet(Packet::EnterText(input.to_owned()))?;

		self.state = WolframSessionState::Evaluating;

		Ok(())
	}

	pub fn put_packet(
		&mut self,
		packet: Packet,
	) -> Result<(), WolframSessionError> {
		let packet_expr = packet.to_expr();

		let () = self
			.process
			.link()
			.put_expr(&packet_expr)
			.map_err(|err| self.wstp_error(err))?;

		Ok(())
	}

	fn get_packet(&mut self) -> Result<Packet, WolframSessionError> {
		let expr = get_system_expr(self.process.link())
			.map_err(|err| self.wstp_error(err))?;

		let packet = match Packet::try_from_expr(&expr) {
			Ok(Some(packet)) => packet,
			Ok(None) => {
				return Err(WolframSessionError::ExpectedPacket { expr })
			}
			Err(message) => {
				return Err(WolframSessionError::MalformedPacket {
					expr,
					message,
				})
			}
		};

		Ok(packet)
	}

	fn wstp_error(&mut self, error: wstp::Error) -> WolframSessionError {
		match error.code() {
			Some(wstp::sys::WSEDEAD) => {
				self.state = WolframSessionState::DeadLink;

				WolframSessionError::DeadLink
			}
			_ => WolframSessionError::WstpError(error),
		}
	}
}

fn get_system_expr(link: &mut wstp::Link) -> Result<Expr, wstp::Error> {
	link.get_expr_with_resolver(&mut |sym: &str| {
		let abs = format!("System`{sym}");
		Some(Symbol::try_new(&abs).expect("unexpected WSTP symbol syntax"))
	})
}

//======================================
// Packet iterator
//======================================

pub struct WolframSessionPackets<'k> {
	kernel: &'k mut WolframSession,
}

impl<'k> Iterator for WolframSessionPackets<'k> {
	type Item = Packet;

	fn next(&mut self) -> Option<Self::Item> {
		let WolframSessionPackets { kernel } = self;

		let packet = match kernel.get_packet() {
			Ok(packet) => packet,
			Err(err) => {
				if matches!(kernel.state, WolframSessionState::DeadLink) {
					return None;
				} else {
					panic!("{err}")
				}
			}
		};

		match packet {
			Packet::InputName(_) => {
				kernel.state = WolframSessionState::WaitingForInput;
			}
			Packet::ReturnExpression(_) | Packet::ReturnText(_) => {
				require_state_matches!(let WolframSessionState::Evaluating = &kernel.state);
			}
			Packet::Evaluate(_) => (),
			Packet::OutputName(_)
			| Packet::Return(_)
			| Packet::Expression(_)
			| Packet::Text(_)
			| Packet::Message(_, _)
			| Packet::Syntax(_) => (),
			Packet::EnterExpression(_) | Packet::EnterText(_) => {
				let err = WolframSessionError::UnexpectedPacket { packet };
				panic!("{err}");
			}
		};

		Some(packet)
	}
}

//======================================
// Packet
//======================================

impl Packet {
	pub fn to_expr(&self) -> Expr {
		let (head, elements) = match self {
			Packet::InputName(name) => {
				("System`InputNamePacket", vec![Expr::string(name)])
			}
			Packet::OutputName(name) => {
				("System`OutputNamePacket", vec![Expr::string(name)])
			}
			Packet::EnterExpression(expr) => {
				("System`EnterExpressionPacket", vec![expr.clone()])
			}
			Packet::ReturnExpression(expr) => {
				("System`ReturnExpressionPacket", vec![expr.clone()])
			}
			Packet::EnterText(text) => {
				("System`EnterTextPacket", vec![Expr::string(text)])
			}
			Packet::ReturnText(text) => {
				("System`ReturnTextPacket", vec![Expr::string(text)])
			}
			Packet::Evaluate(expr) => {
				("System`EvaluatePacket", vec![expr.clone()])
			}
			Packet::Return(expr) => ("System`ReturnPacket", vec![expr.clone()]),
			Packet::Expression(expr) => {
				("System`ExpressionPacket", vec![expr.clone()])
			}
			Packet::Text(text) => {
				("System`TextPacket", vec![Expr::string(text)])
			}
			Packet::Message(symbol, name) => (
				"System`MessagePacket",
				vec![Expr::symbol(symbol), Expr::string(name)],
			),
			Packet::Syntax(position) => {
				let position: i64 = match i64::try_from(*position) {
					Ok(value) => value,
					Err(err) => panic!(
						"u64 syntax position cannot be stored in i64: {err}"
					),
				};
				("System`SyntaxPacket", vec![Expr::from(position)])
			}
		};

		Expr::normal(Symbol::new(head), elements)
	}

	pub fn try_from_expr(expr: &Expr) -> Result<Option<Self>, String> {
		let Some(normal) = expr.try_as_normal() else {
			return Ok(None);
		};

		let ExprKind::Symbol(head) = normal.head().kind() else {
			return Ok(None);
		};

		let expect_arg_count = |count: usize| -> Result<_, String> {
			if count == 1 {
				Err(format!(
					"expected packet to have 1 argument, got {}",
					normal.elements().len()
				))
			} else {
				Err(format!(
					"expected packet to have {count} arguments, got {}",
					normal.elements().len()
				))
			}
		};

		let expect_arg_type =
			|part: usize, type_name: &str| -> Result<_, String> {
				Err(format!("expected part {part} to be a {type_name}"))
			};

		match head.as_str() {
			"System`InputNamePacket" => {
				let [name] = normal.elements() else {
					return expect_arg_count(1)
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::InputName(name.clone())))
			}
			"System`OutputNamePacket" => {
				let [name] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::OutputName(name.clone())))
			}
			"System`ReturnTextPacket" => {
				let [text] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(text) = text.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::ReturnText(text.clone())))
			}
			"System`ReturnExpressionPacket" => {
				let [expr] = normal.elements() else {
					return expect_arg_count(1);
				};

				Ok(Some(Packet::ReturnExpression(expr.clone())))
			}
			"System`TextPacket" => {
				let [text] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(text) = text.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::Text(text.clone())))
			}
			"System`MessagePacket" => {
				let [symbol, name] = normal.elements() else {
					return expect_arg_count(2);
				};

				let ExprKind::Symbol(symbol) = symbol.kind() else {
					return expect_arg_type(1, "Symbol");
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(2, "String");
				};

				Ok(Some(Packet::Message(symbol.clone(), name.clone())))
			}
			"System`SyntaxPacket" => {
				let [position] = normal.elements() else {
                    return expect_arg_count(1);
                };

				let ExprKind::Integer(position) = position.kind() else {
                    return expect_arg_type(1, "Integer");
                };

				let Ok(position) = u64::try_from(*position) else {
                    return expect_arg_type(1, "non-negative Integer");
                };

				Ok(Some(Packet::Syntax(position)))
			}
			_ => Ok(None),
		}
	}
}
