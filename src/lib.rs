//! Wolfram client SDK.
//!
//! This library provides an easy to use API for launching and communicating
//! with a [`WolframKernel`], the main executable in a Wolfram installation.
//!
//! During traditional usage of Wolfram, the user client is the graphical
//! notebook interface, often called the 'FrontEnd'. The user enters commands
//! for evaluation, and the FrontEnd client sends them to the Kernel for
//! evaluation, and displays and printed output and the returned result.
//!
//! See also: ['What is the FrontEnd?'](https://mathematica.stackexchange.com/questions/84173/what-is-the-frontend)
//!
//! This library can be used to implement a programmatic client that can perform
//! evaluations and display output generated by the Wolfram Kernel.
//!
//!
//! ## Use-cases
//!
//! * Call into Wolfram code to add functionality to an existing program.
//!
//!
//! [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
#[cfg(test)]
mod tests;

// Ensure that doc tests in the README.md file get run.
#[doc(hidden)]
mod test_readme {
	#![doc = include_str!("../README.md")]
}

use std::path::Path;

use wolfram_app_discovery::WolframApp;
use wolfram_expr::{Expr, ExprKind, Symbol};
use wstp::kernel::WolframKernelProcess;

/// Handle facilitating structured communication with a running [`WolframKernel`].
///
/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
#[derive(Debug)]
pub struct WolframSession {
	process: WolframKernelProcess,
	state: WolframSessionState,
}

#[non_exhaustive]
#[derive(Debug, thiserror::Error)]
pub enum WolframSessionError {
	#[error(
		"expression is not a known FrontEnd or Kernel packet type: {expr}"
	)]
	ExpectedPacket { expr: Expr },
	#[error(
		"malformed packet expression is malformed: {message} (expr: {expr})"
	)]
	MalformedPacket { expr: Expr, message: String },
	#[error(
		"client does not support packet type sent from Kernel: {packet:?}"
	)]
	ClientUnsupportedPacket { packet: Packet },

	#[error("expected MessagePacket[{symbol}, {name:?}] to be followed by output packet; got: {got:?}")]
	ExpectedMessageContentPacket {
		symbol: Symbol,
		name: String,
		got: Packet,
	},

	#[error("expected evaluation result to be followed by InputNamePacket[_]; got: {got:?}")]
	ExpectedInputNamePacket { got: Packet },

	#[error("the WSTP link used to communicate with the kernel yielded an unexpected error: {0}")]
	WstpError(wstp::Error),
	#[error("the WSTP link used to communicate with the kernel is dead")]
	DeadLink,

	#[error("client only supports operation when the current state matches '{required_state}', but the current state was: {current:?}")]
	OperationNotSupportedInCurrentState {
		required_state: String,
		current: WolframSessionState,
	},
}

//======================================
// Session State
//======================================

#[derive(Debug, Clone)]
pub enum WolframSessionState {
	/// The Kernel process was launched but is not yet ready for user input.
	Launching,

	/// The Kernel is waiting for further input from the user.
	///
	/// Indicates that the Kernel sent an [`InputNamePacket[string]`][InputNamePacket].
	///
	/// [InputNamePacket]: https://reference.wolfram.com/language/ref/InputNamePacket
	WaitingForInput {
		/// Input name specified in `InputNamePacket[string]`.
		input_name: String,
	},

	/// An evaluation is being performed -- the client is waiting for output from
	/// the Kernel.
	Evaluating,

	/// An evaluation finished, but the next `InputNamePacket[_]` hasn't been
	/// received yet.
	FinishedEvaluating,

	/// The WSTP link connection to the Kernel died.
	DeadLink,
}

//======================================
// Packets
//======================================

/// Packet type used in `client <=> WolframKernel` communication.
///
/// ## Request/Response packets
///
/// | Client sends...              | Kernel responds...           |
/// |------------------------------|------------------------------|
/// | [`Packet::EnterExpression`]  | [`Packet::ReturnExpression`] |
/// | [`Packet::EnterText`]        | [`Packet::ReturnText`]       |
/// | [`Packet::Evaluate`]         | [`Packet::Return`]           |
///
/// ## Evaluation non-final output
///
/// The following packet types are sent by the Kernel to the client when output
/// is printed during the evaluation:
///
/// | Kernel sends...         |
/// |-------------------------|
/// | [`Packet::Expression`]  |
/// | [`Packet::Text`]        |
/// | [`Packet::Message`]     |
#[derive(Debug)]
pub enum Packet {
	/// [`InputNamePacket`]
	///
	/// [`InputNamePacket`]: https://reference.wolfram.com/language/ref/InputNamePacket
	InputName(String),

	/// [`OutputNamePacket`]
	///
	/// [`OutputNamePacket`]: https://reference.wolfram.com/language/ref/OutputNamePacket
	OutputName(String),

	/// [`EnterExpressionPacket`]
	///
	/// [`EnterExpressionPacket`]: https://reference.wolfram.com/language/ref/EnterExpressionPacket
	EnterExpression(Expr),

	/// [`ReturnExpressionPacket`]
	///
	/// [`ReturnExpressionPacket`]: https://reference.wolfram.com/language/ref/ReturnExpressionPacket
	ReturnExpression(Expr),

	/// [`EnterTextPacket`]
	///
	/// [`EnterTextPacket`]: https://reference.wolfram.com/language/ref/EnterTextPacket
	EnterText(String),

	/// [`ReturnTextPacket`]
	///
	/// [`ReturnTextPacket`]: https://reference.wolfram.com/language/ref/ReturnTextPacket
	ReturnText(String),

	/// [`EvaluatePacket`]
	///
	/// [`EvaluatePacket`]: https://reference.wolfram.com/language/ref/EvaluatePacket
	Evaluate(Expr),

	/// [`ReturnPacket`]
	///
	/// [`ReturnPacket`]: https://reference.wolfram.com/language/ref/ReturnPacket
	Return(Expr),

	/// `ExpressionPacket`.
	///
	/// This packet type has no official documentation. Observed behavior:
	///
	/// - [`ExpressionPacket[BoxData[..]]`] is sent from the Kernel to the FE
	///   when `Print[..]` is evaluated.
	Expression(Expr),

	/// [`TextPacket`]
	///
	/// [`TextPacket`]: https://reference.wolfram.com/language/ref/TextPacket
	Text(String),

	/// [`MessagePacket`]
	///
	/// [`MessagePacket`]: https://reference.wolfram.com/language/ref/MessagePacket
	Message(Symbol, String),

	/// [`SyntaxPacket`]
	///
	/// [`SyntaxPacket`]: https://reference.wolfram.com/language/ref/SyntaxPacket
	Syntax(u64),
}

//======================================
// Evaluation Outcome
//======================================

/// Data collected from the Kernel during a blocking evaluation.
///
/// This is returned by [`WolframSession::enter_and_wait()`].
#[derive(Debug)]
pub struct EvaluationData {
	/// Output generated during the evaluation.
	///
	/// The output is stored in the order it was received from the Kernel.
	pub output: Vec<Output>,

	/// The outcome of the evaluation.
	pub outcome: EvaluationOutcome,
}

#[derive(Debug, PartialEq)]
pub enum EvaluationOutcome {
	/// The evaluation completed and returned a non-Null result.
	Returned(PacketExpr),

	/// The evaluation completed and yielded [`Null`], so no result was
	/// returned to the client.
	///
	/// [`Null`]: https://reference.wolfram.com/language/ref/Null
	Null,

	/// The Kernel quit during the evaluation.
	///
	// TODO: Expectedly or unexpectedly; can we know? During or after the
	//       evaluation completed?
	KernelQuit,
}

#[derive(Debug, PartialEq)]
pub enum Output {
	Print(PacketExpr),
	Message(Message),
}

/// Representation of expression in [`Packet`]s.
///
/// **Input** — Expression sent from the client to the Kernel for evaluation.
///
/// **Printed** — Output intended for display to the user, typically sent by a
///               [`Print`], [`Message`], or [`Echo`] during an evaluation.
///
/// [`Print`]: https://reference.wolfram.com/language/ref/Print
/// [`Message`]: https://reference.wolfram.com/language/ref/Message
/// [`Echo`]: https://reference.wolfram.com/language/ref/Echo
#[derive(Debug, PartialEq)]
pub enum PacketExpr {
	/// Literal expression.
	///
	/// **Input:** [`Packet::EnterExpression`] or [`Packet::Evaluate`]
	///
	/// **Printed:** [`Packet::Expression`]
	///
	/// **Returned:** [`Packet::ReturnExpression`] or [`Packet::Return`]
	Expr(Expr),
	/// Textual expression representation.
	///
	/// This may validly be [`InputForm`] or [`OutputForm`] content, depending
	/// on whether this content was part of a packet sent to or from the Kernel,
	/// respectively.
	///
	/// **Input:** [`Packet::EnterText`]
	///
	/// **Printed:** [`Packet::Text`]
	///
	/// **Returned:** [`Packet::ReturnText`]
	///
	/// [`InputForm`]: https://reference.wolfram.com/language/ref/InputForm
	/// [`OutputForm`]: https://reference.wolfram.com/language/ref/OutputForm
	Text(String),
}

/// Message sent from the Kernel to the FrontEnd for display to the user.
#[derive(Debug, PartialEq)]
pub struct Message {
	pub symbol: Symbol,
	pub name: String,
	pub content: PacketExpr,
}

//======================================
// Impls
//======================================

#[rustfmt::skip]
macro_rules! require_state_matches {
	(let $expected:pat = $state:expr) => {
		let state: &crate::WolframSessionState = $state;

		let $expected = state else {
			let error = WolframSessionError::OperationNotSupportedInCurrentState {
				required_state: String::from(stringify!($expected)),
				current: state.clone()
			};

			panic!("{error}")
		};
	};
}

impl WolframSession {
	/// Launch the default [`WolframKernel`] found on this computer. *(Blocking.)*
	///
	/// This method uses
	/// [`wolfram-app-discovery`](https://crates.io/crates/wolfram-app-discovery)
	/// to automatically locate any local Wolfram installations.
	///
	/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
	pub fn launch_default_kernel() -> Result<Self, wstp::kernel::Error> {
		let app = WolframApp::try_default()
			.expect("unable to find any Wolfram Language installations");

		let exe = app.kernel_executable_path().unwrap();

		WolframSession::launch_kernel(exe.as_path())
	}

	/// Start a new `WolframSession` by spawning a new [`WolframKernel`]
	/// process. *(Blocking.)*
	///
	/// [`WolframKernel`]: https://reference.wolfram.com/language/ref/program/WolframKernel
	pub fn launch_kernel(
		kernel_exe: &Path,
	) -> Result<Self, wstp::kernel::Error> {
		let kernel_exe = kernel_exe.to_owned();

		let process = WolframKernelProcess::launch(&kernel_exe)?;

		Ok(WolframSession {
			process,
			state: WolframSessionState::Launching,
		})
	}

	/// Iterator over [`Packet`]s sent from the Kernel to the client.
	///
	/// Iterating over packets will automatically update
	/// [`self.state()`][Self::state].
	pub fn packets(&mut self) -> WolframSessionPackets {
		WolframSessionPackets { kernel: self }
	}

	pub fn state(&self) -> &WolframSessionState {
		let WolframSession { process: _, state } = self;

		state
	}

	//==================================
	// Blocking evaluation interface
	//==================================

	/// Perform an evaluation and wait until the result is returned. *(Blocking.)*
	///
	/// This function sends [`Packet::EnterExpression`] or
	/// [`Packet::EnterText`] to the Kernel.
	///
	/// # Examples
	///
	/// Perform a computation and wait for the result:
	///
	/// ```
	/// use wolfram_client::{WolframSession, Packet, PacketExpr};
	///
	/// let mut kernel = WolframSession::launch_default_kernel().unwrap();
	///
	/// let Packet::InputName(_) = kernel.packets().next().unwrap() else { panic!() };
	///
	/// let returned = kernel.enter_and_wait("2 + 2").outcome.unwrap_returned();
	///
	/// assert_eq!(returned, PacketExpr::Text("4".to_owned()));
	/// ```
	///
	/// # Panics
	///
	/// This function panics if the underlying call to
	/// [`try_enter_and_wait()`][Self::try_enter_and_wait] returns an error.
	pub fn enter_and_wait<E: Into<PacketExpr>>(
		&mut self,
		input: E,
	) -> EvaluationData {
		let input: PacketExpr = input.into();
		self.try_enter_and_wait(input)
			.expect("error waiting for evaluation result of entered input")
	}

	/// Perform an evaluation and wait until the result is returned. *(Blocking.)*
	///
	/// # Errors
	///
	/// This function will return an error if:
	///
	/// * There is an error during the underlying call to [`put_packet()`][Self::put_packet]
	/// * A WSTP error occurs.
	///
	pub fn try_enter_and_wait(
		&mut self,
		input: PacketExpr,
	) -> Result<EvaluationData, WolframSessionError> {
		let mut output: Vec<Output> = Vec::new();

		let outcome = self.try_enter_and_wait_with_output_handler(
			input,
			&mut |o: Output| output.push(o),
		)?;

		Ok(EvaluationData { output, outcome })
	}

	/// Perform an evaluation and wait until the result is returned, calling an
	/// output handler on printed output. *(Blocking.)*
	///
	/// This function sends [`Packet::EnterExpression`] or
	/// [`Packet::EnterText`] to the Kernel.
	///
	/// # Examples
	///
	/// Perform an evaluation, and immediately print any output as it is sent
	/// from the Kernel:
	///
	/// ```
	/// use wolfram_client::{WolframSession, Packet, Output, EvaluationOutcome};
	///
	/// let mut session = WolframSession::launch_default_kernel().unwrap();
	///
	/// // In[1]:=
	/// let Packet::InputName(_) = session.packets().next().unwrap() else { panic!() };
	///
	/// // Start an evaluation that produces output as it progresses.
	/// let outcome = session.enter_and_wait_with_output_handler(
	/// 	"Do[Print[i], {i, 5}]",
	/// 	&mut |output: Output| {
	/// 		println!("{output:?}")
	/// 	}
	/// );
	///
	/// assert!(outcome == EvaluationOutcome::Null);
	/// ```
	///
	/// # Panics
	///
	/// This function panics if the underlying call to
	/// [`try_enter_and_wait_with_output_handler()`][Self::try_enter_and_wait_with_output_handler]
	/// returns an error.
	pub fn enter_and_wait_with_output_handler<E: Into<PacketExpr>>(
		&mut self,
		input: E,
		handle_output: &mut dyn FnMut(Output),
	) -> EvaluationOutcome {
		let input: PacketExpr = input.into();
		self.try_enter_and_wait_with_output_handler(input, handle_output)
			.expect("error waiting for evaluation result of entered input")
	}

	/// Perform an evaluation and wait until the result is returned, calling an
	/// output handler on printed output. *(Blocking.)*
	///
	/// # Errors
	///
	/// This function will return an error if:
	///
	/// * There is an error during the underlying call to [`put_packet()`][Self::put_packet]
	/// * A WSTP error occurs.
	///
	pub fn try_enter_and_wait_with_output_handler(
		&mut self,
		input: PacketExpr,
		handle_output: &mut dyn FnMut(Output),
	) -> Result<EvaluationOutcome, WolframSessionError> {
		require_state_matches!(
			// Note: This can't be FinishedEvaluating because the next
			// InputNamePacket[_] we receive has to mean the evaluation finished
			// with a (possibly Null) result.
			let WolframSessionState::WaitingForInput { .. } = self.state()
		);

		//
		// Send `input` for evaluation
		//

		match input {
			PacketExpr::Expr(expr) => {
				self.put_packet(Packet::EnterExpression(expr))?
			}
			PacketExpr::Text(input) => {
				self.put_packet(Packet::EnterText(input))?
			}
		}

		self.state = WolframSessionState::Evaluating;

		//
		// Process packets sent back from the Kernel.
		//

		let outcome: EvaluationOutcome = loop {
			let Some(packet) = self.packets().next() else {
				debug_assert!(matches!(self.state, WolframSessionState::DeadLink));
                break EvaluationOutcome::KernelQuit;
            };

			match packet {
				// If the evaluation result is Null, no Return*Packet[..] is sent,
				// and the next packet the client reads is an InputNamePacket[..].
				Packet::InputName(_) => {
					debug_assert!(matches!(
						self.state,
						WolframSessionState::WaitingForInput { .. }
					));
					break EvaluationOutcome::Null;
				}
				// Continue to the next iteration of the loop to return the
				// Return*Packet[__].
				Packet::OutputName(_) => (),
				Packet::ReturnExpression(expr) => {
					// TODO: What if this contains boxes?
					break EvaluationOutcome::Returned(PacketExpr::Expr(expr));
				}
				Packet::ReturnText(text) => {
					break EvaluationOutcome::Returned(PacketExpr::Text(text))
				}
				Packet::Return(expr) => {
					break EvaluationOutcome::Returned(PacketExpr::Expr(expr))
				}
				// TODO: What if this contains boxes?
				Packet::Expression(expr) => {
					handle_output(Output::Print(PacketExpr::Expr(expr)))
				}
				Packet::Text(text) => {
					handle_output(Output::Print(PacketExpr::Text(text)))
				}
				Packet::Message(symbol, name) => {
					handle_output(Output::Message(
						self.get_message_content_packet(symbol, name)?,
					))
				}
				// TODO: Do something with syntax packets? SyntaxPacket[..]s
				//       seem to always be preceded by MessagePacket[..]s, so
				//       the syntax packet doesn't seem to add much.
				Packet::Syntax(_) => (),
				// TODO: Are there any reasons the Kernel might ask the client
				//       to perform an evaluation. E.g. getting a FE value?
				Packet::Evaluate(_)
				| Packet::EnterExpression(_)
				| Packet::EnterText(_) => {
					return Err(WolframSessionError::ClientUnsupportedPacket {
						packet,
					})
				}
			}
		};

		match outcome {
			EvaluationOutcome::Null => {
				debug_assert!(matches!(
					self.state,
					WolframSessionState::WaitingForInput { .. }
				))
			}
			EvaluationOutcome::Returned(_) => {
				// Advance to read the next packet, which we expect to be
				// InputNamePacket[_] or the Kernel quit.
				match self.packets().next() {
					Some(Packet::InputName(_)) => {
						debug_assert!(matches!(
							self.state,
							WolframSessionState::WaitingForInput { .. }
						))
					}
					Some(other) => {
						return Err(
							WolframSessionError::ExpectedInputNamePacket {
								got: other,
							},
						)
					}
					None => {
						debug_assert!(matches!(
							self.state,
							WolframSessionState::DeadLink
						))
					}
				}
			}
			EvaluationOutcome::KernelQuit => {
				debug_assert!(matches!(
					self.state,
					WolframSessionState::DeadLink
				))
			}
		}

		// Iterating over packets should have updated the state automatically.
		debug_assert!(matches!(
			self.state,
			WolframSessionState::WaitingForInput { .. }
				| WolframSessionState::DeadLink
		));

		Ok(outcome)
	}

	/// A `MessagePacket` MUST be followed by a `TextPacket` or
	/// `ExpressionPacket` containing the content of the message.
	///
	/// 1. `MessagePacket[..]`
	/// 2. `TextPacket[..]` OR `ExpressionPacket[..]`
	fn get_message_content_packet(
		&mut self,
		symbol: Symbol,
		name: String,
	) -> Result<Message, WolframSessionError> {
		let message_content_packet = self.get_packet()?;

		let content = match message_content_packet {
			Packet::Text(text) => PacketExpr::Text(text),
			Packet::Expression(expr) => PacketExpr::Expr(expr),
			other => {
				return Err(WolframSessionError::ExpectedMessageContentPacket {
					symbol,
					name,
					got: other,
				})
			}
		};

		Ok(Message {
			symbol,
			name,
			content,
		})
	}

	//==================================
	// Packet-oriented interface
	//==================================

	/// Enter `input` to be evaluated by the Kernel. *(Non-blocking.)*
	///
	/// This function sends [`Packet::EnterText`] to the Kernel.
	///
	/// # Panics
	///
	/// This function panics if the underlying call to
	/// [`self.try_enter_text()`][Self::try_enter_text] returns an error.
	pub fn enter_text(&mut self, input: &str) {
		self.try_enter_text(input)
			.expect("kernel session error during enter_text()")
	}

	/// Enter `input` to be evaluated by the Kernel. *(Non-blocking.)*
	///
	/// This function sends [`Packet::EnterText`] to the Kernel.
	///
	/// # Errors
	///
	/// This function will return an error if:
	///
	/// * [`self.state()`][Self::state] is not [`WolframSessionState::WaitingForInput`]
	/// * The underlying [`put_packet()`][Self::put_packet] call returns an error.
	pub fn try_enter_text(
		&mut self,
		input: &str,
	) -> Result<(), WolframSessionError> {
		require_state_matches!(let WolframSessionState::WaitingForInput { .. } = self.state());

		self.put_packet(Packet::EnterText(input.to_owned()))?;

		self.state = WolframSessionState::Evaluating;

		Ok(())
	}

	/// *(Non-blocking.)*
	pub fn put_packet(
		&mut self,
		packet: Packet,
	) -> Result<(), WolframSessionError> {
		let packet_expr = packet.to_expr();

		let () = self
			.process
			.link()
			.put_expr(&packet_expr)
			.map_err(|err| self.wstp_error(err))?;

		// TODO: Call link().flush() here?

		Ok(())
	}

	fn get_packet(&mut self) -> Result<Packet, WolframSessionError> {
		let expr = get_system_expr(self.process.link())
			.map_err(|err| self.wstp_error(err))?;

		let packet = match Packet::try_from_expr(&expr) {
			Ok(Some(packet)) => packet,
			Ok(None) => {
				return Err(WolframSessionError::ExpectedPacket { expr })
			}
			Err(message) => {
				return Err(WolframSessionError::MalformedPacket {
					expr,
					message,
				})
			}
		};

		Ok(packet)
	}

	//==================================
	// WSTP messages
	//==================================

	/// Send a WSTP urgent message to the Kernel. *(Non-blocking.)*
	///
	/// # Examples
	///
	/// Abort a long-running computation by sending
	/// [`UrgentMessage::ABORT`][wstp::UrgentMessage::ABORT]
	/// to the Kernel.
	///
	/// ```
	/// use wstp::UrgentMessage;
	/// use wolfram_client::{WolframSession, Packet};
	/// use wolfram_expr::Symbol;
	///
	/// let mut kernel = WolframSession::launch_default_kernel().unwrap();
	///
	/// // In[1]:=
	/// let Packet::InputName(_) = kernel.packets().next().unwrap() else { panic!() };
	///
	/// // Start a long-running computation.
	/// kernel.enter_text("Pause[10]");
	///
	/// // Tell the Kernel to abort the current computation.
	/// kernel.put_message(UrgentMessage::ABORT).unwrap();
	///
	/// // Out[1]=
	/// let Packet::OutputName(_) = kernel.packets().next().unwrap() else { panic!() };
	///
	/// let Packet::ReturnExpression(result) = kernel.packets().next().unwrap() else { panic!() };
	///
	///	assert_eq!(result, Symbol::new("System`$Aborted"));
	/// ```
	pub fn put_message(
		&mut self,
		message: wstp::UrgentMessage,
	) -> Result<(), wstp::Error> {
		// TODO: Update `self.state` based on the message type?
		self.process.link().put_message(message)
	}

	fn wstp_error(&mut self, error: wstp::Error) -> WolframSessionError {
		match error.code() {
			// TODO: Would it make sense to represent WSECLOSED and WSEDEAD with
			//       different errors/states? Empirically, it seems that both
			//       are observed even if the Kernel terminates gracefully due
			//       to an evaluation of Exit[].
			Some(wstp::sys::WSECLOSED | wstp::sys::WSEDEAD) => {
				self.state = WolframSessionState::DeadLink;

				WolframSessionError::DeadLink
			}
			_ => WolframSessionError::WstpError(error),
		}
	}
}

fn get_system_expr(link: &mut wstp::Link) -> Result<Expr, wstp::Error> {
	link.get_expr_with_resolver(&mut |sym: &str| {
		let abs = format!("System`{sym}");
		Some(Symbol::try_new(&abs).expect("unexpected WSTP symbol syntax"))
	})
}

//======================================
// Packet iterator
//======================================

pub struct WolframSessionPackets<'k> {
	kernel: &'k mut WolframSession,
}

impl<'k> Iterator for WolframSessionPackets<'k> {
	type Item = Packet;

	fn next(&mut self) -> Option<Self::Item> {
		let WolframSessionPackets { kernel } = self;

		let packet = match kernel.get_packet() {
			Ok(packet) => packet,
			Err(err) => {
				if matches!(kernel.state, WolframSessionState::DeadLink) {
					return None;
				} else {
					// TODO: Expose this error as part of the iterator
					panic!("{err}")
				}
			}
		};

		match packet {
			Packet::InputName(ref input_name) => {
				kernel.state = WolframSessionState::WaitingForInput {
					input_name: input_name.clone(),
				};
			}
			Packet::ReturnExpression(_) | Packet::ReturnText(_) => {
				if cfg!(debug_assertions) {
					require_state_matches!(let WolframSessionState::Evaluating = &kernel.state);
				}

				kernel.state = WolframSessionState::FinishedEvaluating;
			}
			Packet::Evaluate(_) => (),
			Packet::OutputName(_)
			| Packet::Return(_)
			| Packet::Expression(_)
			| Packet::Text(_)
			| Packet::Message(_, _)
			| Packet::Syntax(_) => (),
			// TODO: Don't generate an error here? Some clients might support
			//       these packets?
			Packet::EnterExpression(_) | Packet::EnterText(_) => {
				let err =
					WolframSessionError::ClientUnsupportedPacket { packet };
				panic!("{err}");
			}
		};

		Some(packet)
	}
}

//======================================
// Packet
//======================================

impl Packet {
	pub fn to_expr(&self) -> Expr {
		let (head, elements) = match self {
			Packet::InputName(name) => {
				("System`InputNamePacket", vec![Expr::string(name)])
			}
			Packet::OutputName(name) => {
				("System`OutputNamePacket", vec![Expr::string(name)])
			}
			Packet::EnterExpression(expr) => {
				("System`EnterExpressionPacket", vec![expr.clone()])
			}
			Packet::ReturnExpression(expr) => {
				("System`ReturnExpressionPacket", vec![expr.clone()])
			}
			Packet::EnterText(text) => {
				("System`EnterTextPacket", vec![Expr::string(text)])
			}
			Packet::ReturnText(text) => {
				("System`ReturnTextPacket", vec![Expr::string(text)])
			}
			Packet::Evaluate(expr) => {
				("System`EvaluatePacket", vec![expr.clone()])
			}
			Packet::Return(expr) => ("System`ReturnPacket", vec![expr.clone()]),
			Packet::Expression(expr) => {
				("System`ExpressionPacket", vec![expr.clone()])
			}
			Packet::Text(text) => {
				("System`TextPacket", vec![Expr::string(text)])
			}
			Packet::Message(symbol, name) => (
				"System`MessagePacket",
				vec![Expr::symbol(symbol), Expr::string(name)],
			),
			Packet::Syntax(position) => {
				let position: i64 = match i64::try_from(*position) {
					Ok(value) => value,
					Err(err) => panic!(
						"u64 syntax position cannot be stored in i64: {err}"
					),
				};
				("System`SyntaxPacket", vec![Expr::from(position)])
			}
		};

		Expr::normal(Symbol::new(head), elements)
	}

	pub fn try_from_expr(expr: &Expr) -> Result<Option<Self>, String> {
		let Some(normal) = expr.try_as_normal() else {
			return Ok(None);
		};

		let ExprKind::Symbol(head) = normal.head().kind() else {
			return Ok(None);
		};

		let expect_arg_count = |count: usize| -> Result<_, String> {
			if count == 1 {
				Err(format!(
					"expected packet to have 1 argument, got {}",
					normal.elements().len()
				))
			} else {
				Err(format!(
					"expected packet to have {count} arguments, got {}",
					normal.elements().len()
				))
			}
		};

		let expect_arg_type =
			|part: usize, type_name: &str| -> Result<_, String> {
				Err(format!("expected part {part} to be a {type_name}"))
			};

		match head.as_str() {
			"System`InputNamePacket" => {
				let [name] = normal.elements() else {
					return expect_arg_count(1)
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::InputName(name.clone())))
			}
			"System`OutputNamePacket" => {
				let [name] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::OutputName(name.clone())))
			}
			"System`ReturnTextPacket" => {
				let [text] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(text) = text.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::ReturnText(text.clone())))
			}
			"System`ReturnExpressionPacket" => {
				let [expr] = normal.elements() else {
					return expect_arg_count(1);
				};

				Ok(Some(Packet::ReturnExpression(expr.clone())))
			}
			"System`TextPacket" => {
				let [text] = normal.elements() else {
					return expect_arg_count(1);
				};

				let ExprKind::String(text) = text.kind() else {
					return expect_arg_type(1, "String");
				};

				Ok(Some(Packet::Text(text.clone())))
			}
			"System`MessagePacket" => {
				let [symbol, name] = normal.elements() else {
					return expect_arg_count(2);
				};

				let ExprKind::Symbol(symbol) = symbol.kind() else {
					return expect_arg_type(1, "Symbol");
				};

				let ExprKind::String(name) = name.kind() else {
					return expect_arg_type(2, "String");
				};

				Ok(Some(Packet::Message(symbol.clone(), name.clone())))
			}
			"System`SyntaxPacket" => {
				let [position] = normal.elements() else {
                    return expect_arg_count(1);
                };

				let ExprKind::Integer(position) = position.kind() else {
                    return expect_arg_type(1, "Integer");
                };

				let Ok(position) = u64::try_from(*position) else {
                    return expect_arg_type(1, "non-negative Integer");
                };

				Ok(Some(Packet::Syntax(position)))
			}
			_ => Ok(None),
		}
	}
}

//======================================
// Evaluation results
//======================================

impl EvaluationOutcome {
	/// Expect this evaluation to have returned a result.
	///
	/// If `self` is [`EvaluationOutcome::Returned(expr)`], then `expr` will be
	/// returned.
	///
	/// Otherwise, this function will panic.
	#[track_caller]
	pub fn unwrap_returned(self) -> PacketExpr {
		match self {
            EvaluationOutcome::Returned(returned) => returned,
			EvaluationOutcome::Null => panic!("unable to unwrap returned evaluation: evaluation result was Null"),
            EvaluationOutcome::KernelQuit => panic!("unable to unwrap returned evaluation: Kernel quit during evaluation"),
        }
	}

	/// Expect this evaluation to have resulted in [`Null`].
	///
	/// If `self` is [`EvaluationOutcome::Null`], then this function will return
	/// normally.
	///
	/// Otherwise, this function will panic.
	///
	/// [`Null`]: https://reference.wolfram.com/language/ref/Null
	#[track_caller]
	pub fn unwrap_null(self) {
		match self {
            EvaluationOutcome::Returned(returned) => panic!("unable to unwrap null: evaluation returned a result: {returned:?}"),
			EvaluationOutcome::Null => (),
            EvaluationOutcome::KernelQuit => panic!("unable to unwrap returned evaluation: Kernel quit during evaluation"),
        }
	}
}

impl From<Expr> for PacketExpr {
	fn from(expr: Expr) -> PacketExpr {
		PacketExpr::Expr(expr)
	}
}

impl<'s> From<&str> for PacketExpr {
	fn from(input: &str) -> PacketExpr {
		PacketExpr::Text(input.to_owned())
	}
}

impl From<String> for PacketExpr {
	fn from(input: String) -> PacketExpr {
		PacketExpr::Text(input)
	}
}
